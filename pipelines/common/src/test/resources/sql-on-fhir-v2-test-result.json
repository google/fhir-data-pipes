{
  "logic.json": {
    "tests": [
      {
        "name": "filtering with 'and'",
        "passed": true
      },
      {
        "name": "filtering with 'or'",
        "passed": true
      },
      {
        "name": "filtering with 'not'",
        "passed": true
      }
    ]
  },
  "fn_join.json": {
    "tests": [
      {
        "name": "join with comma",
        "passed": true
      },
      {
        "name": "join with empty value",
        "passed": true
      },
      {
        "name": "fn_join",
        "passed": false,
        "failureReason": "skipped"
      }
    ]
  },
  "fhirpath.json": {
    "tests": [
      {
        "name": "one element",
        "passed": true
      },
      {
        "name": "two elements + first",
        "passed": true
      },
      {
        "name": "collection",
        "passed": true
      },
      {
        "name": "index[0]",
        "passed": true
      },
      {
        "name": "index[1]",
        "passed": true
      },
      {
        "name": "out of index",
        "passed": true
      },
      {
        "name": "where",
        "passed": true
      },
      {
        "name": "exists",
        "passed": true
      },
      {
        "name": "nested exists",
        "passed": true
      },
      {
        "name": "string join",
        "passed": true
      },
      {
        "name": "fhirpath",
        "passed": false,
        "failureReason": "skipped"
      }
    ]
  },
  "fn_oftype.json": {
    "tests": [
      {
        "name": "select string values",
        "passed": true
      },
      {
        "name": "select integer values",
        "passed": true
      }
    ]
  },
  "fn_extension.json": {
    "tests": [
      {
        "name": "simple extension",
        "passed": true
      },
      {
        "name": "nested extension",
        "passed": true
      }
    ]
  },
  "fn_boundary.json": {
    "tests": [
      {
        "name": "decimal lowBoundary",
        "passed": true
      },
      {
        "name": "decimal highBoundary",
        "passed": true
      },
      {
        "name": "datetime lowBoundary",
        "passed": true
      },
      {
        "name": "datetime highBoundary",
        "passed": true
      },
      {
        "name": "fn_boundary",
        "passed": false,
        "failureReason": "skipped"
      },
      {
        "name": "time lowBoundary",
        "passed": true
      },
      {
        "name": "time highBoundary",
        "passed": true
      }
    ]
  },
  "view_resource.json": {
    "tests": [
      {
        "name": "only pts",
        "passed": true
      },
      {
        "name": "only obs",
        "passed": true
      },
      {
        "name": "resource not specified",
        "passed": true
      }
    ]
  },
  "constant.json": {
    "tests": [
      {
        "name": "constant in path",
        "passed": true
      },
      {
        "name": "constant in forEach",
        "passed": true
      },
      {
        "name": "constant in where element",
        "passed": true
      },
      {
        "name": "constant in unionAll",
        "passed": true
      },
      {
        "name": "integer constant",
        "passed": true
      },
      {
        "name": "boolean constant",
        "passed": true
      },
      {
        "name": "accessing an undefined constant",
        "passed": true
      },
      {
        "name": "incorrect constant definition",
        "passed": true
      }
    ]
  },
  "fn_empty.json": {
    "tests": [
      {
        "name": "empty names",
        "passed": true
      }
    ]
  },
  "union.json": {
    "tests": [
      {
        "name": "basic",
        "passed": true
      },
      {
        "name": "unionAll + column",
        "passed": true
      },
      {
        "name": "duplicates",
        "passed": true
      },
      {
        "name": "empty results",
        "passed": true
      },
      {
        "name": "empty with forEachOrNull",
        "passed": true
      },
      {
        "name": "forEachOrNull and forEach",
        "passed": true
      },
      {
        "name": "nested",
        "passed": true
      },
      {
        "name": "one empty operand",
        "passed": true
      },
      {
        "name": "column mismatch",
        "passed": true
      },
      {
        "name": "column order mismatch",
        "passed": true
      }
    ]
  },
  "fhirpath_numbers.json": {
    "tests": [
      {
        "name": "add observation",
        "passed": true
      }
    ]
  },
  "combinations.json": {
    "tests": [
      {
        "name": "select",
        "passed": true
      },
      {
        "name": "column + select",
        "passed": true
      },
      {
        "name": "sibling select",
        "passed": true
      },
      {
        "name": "sibling select inside a select",
        "passed": true
      },
      {
        "name": "column + select, with where",
        "passed": true
      },
      {
        "name": "unionAll + forEach + column + select",
        "passed": true
      }
    ]
  },
  "validate.json": {
    "tests": [
      {
        "name": "empty",
        "passed": true
      },
      {
        "name": "missing resource",
        "passed": true
      },
      {
        "name": "wrong fhirpath",
        "passed": true
      },
      {
        "name": "validate",
        "passed": false,
        "failureReason": "skipped"
      },
      {
        "name": "where with path resolving to not boolean",
        "passed": true
      }
    ]
  },
  "where.json": {
    "tests": [
      {
        "name": "simple where path with result",
        "passed": true
      },
      {
        "name": "where path with no results",
        "passed": true
      },
      {
        "name": "where path with greater than inequality",
        "passed": true
      },
      {
        "name": "where path with less than inequality",
        "passed": true
      },
      {
        "name": "multiple where paths",
        "passed": true
      },
      {
        "name": "where path with an 'and' connector",
        "passed": true
      },
      {
        "name": "where path with an 'or' connector",
        "passed": true
      },
      {
        "name": "where path that evaluates to true when empty",
        "passed": true
      }
    ]
  },
  "basic.json": {
    "tests": [
      {
        "name": "basic attribute",
        "passed": true
      },
      {
        "name": "boolean attribute with false",
        "passed": true
      },
      {
        "name": "two columns",
        "passed": true
      },
      {
        "name": "two selects with columns",
        "passed": true
      },
      {
        "name": "where - 1",
        "passed": true
      },
      {
        "name": "where - 2",
        "passed": true
      },
      {
        "name": "where returns non-boolean for some cases",
        "passed": true
      },
      {
        "name": "where as expr - 1",
        "passed": true
      },
      {
        "name": "where as expr - 2",
        "passed": true
      },
      {
        "name": "select & column",
        "passed": true
      }
    ]
  },
  "foreach.json": {
    "tests": [
      {
        "name": "forEach: normal",
        "passed": true
      },
      {
        "name": "forEachOrNull: basic",
        "passed": true
      },
      {
        "name": "forEach: empty",
        "passed": true
      },
      {
        "name": "forEach: two on the same level",
        "passed": true
      },
      {
        "name": "forEach: two on the same level (empty result)",
        "passed": true
      },
      {
        "name": "forEachOrNull: null case",
        "passed": true
      },
      {
        "name": "forEach and forEachOrNull on the same level",
        "passed": true
      },
      {
        "name": "nested forEach",
        "passed": true
      },
      {
        "name": "nested forEach: select & column",
        "passed": true
      },
      {
        "name": "forEachOrNull & unionAll on the same level",
        "passed": true
      },
      {
        "name": "forEach & unionAll on the same level",
        "passed": true
      },
      {
        "name": "forEach & unionAll & column & select on the same level",
        "passed": true
      },
      {
        "name": "forEachOrNull & unionAll & column & select on the same level",
        "passed": true
      }
    ]
  },
  "fn_first.json": {
    "tests": [
      {
        "name": "table level first()",
        "passed": true
      },
      {
        "name": "table and field level first()",
        "passed": true
      }
    ]
  },
  "fn_reference_keys.json": {
    "tests": [
      {
        "name": "getReferenceKey result matches getResourceKey without type specifier",
        "passed": true
      },
      {
        "name": "getReferenceKey result matches getResourceKey with right type specifier",
        "passed": true
      },
      {
        "name": "getReferenceKey result matches getResourceKey with wrong type specifier",
        "passed": true
      }
    ]
  },
  "collection.json": {
    "tests": [
      {
        "name": "fail when 'collection' is not true",
        "passed": true
      },
      {
        "name": "collection = true",
        "passed": true
      },
      {
        "name": "collection = false relative to forEach parent",
        "passed": true
      },
      {
        "name": "collection = false relative to forEachOrNull parent",
        "passed": true
      }
    ]
  }
}